[TOC]



# Part 1: Python Basics

## 1. Loop



- `range(4)=range(0,4)`  -> `(0,1,2,3)`
- `range(i,j,k)`

```python
for i in range(n):
  
for i in s:  # s can be a string
  
for i, a in enumerate(list_or_str, start=1): # retrive both index and value

# if we do not care about the index, but we are doing multiple lists, use zip():
for a, b in zip(list_1, list_2):
  
```

### Enumerate 

```python
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
print(list(enumerate(seasons)))
print(list(enumerate(seasons, start=1)))

# Result:
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

### Zip

```python
x, y = [1,2,3],[4,5,6]
print(list(zip(x,y)))                    
x2, y2 = zip(*zip(x, y))
print(x2, y2)

# Result:
[(1, 4), (2, 5), (3, 6)]
(1, 2, 3) (4, 5, 6)
```



### for loop with else

A for loop can have an optional else block as well. The `else` part is executed if the items in the sequence used in for loop exhausts.

break statement can be used to stop a for loop. In such case, the else part is ignored.

A for loop's else part runs <u>if no break occurs</u>.



### while loop with else

Same as that of for loop, we can have an optional `else` block with while loop as well.

The `else` part is executed if the condition in the while loop evaluates to `False`.

A while loop's `else` part runs if no break occurs and the condition is false.



## 2. Function

- Note: one function will only have one `return`
  - If there is no `return` statement, the function returns `None`
  - Place documentation before the body by tripe quotes
  - `break`: to exit the current loop
  - `continue`: stop the current iteration and continue the **next** iteration.

```python
class solution():
  def Function_Name(self, x: int) -> int:
    .....
    return 

solution().Function_Name(x)

# default value
def add(a=0):
    return(a+1)

# can claim global variable inside a function
def foo(abc):
    global aa
    aa = abc + 1
    return(aa)
```

###  lambda

A lambda operator or lambda function is used for creating small, one-time, anonymous **function objects** in Python.

```python
# Syntax:
lambda arguments : expression

# Example:
x = lambda a, b, c : a + b + c
print(x(5, 6, 2))
```



### Iterable: map, filter

```python
map(function_object, iterable1, iterable2,...)
# it returns a map object, use list()

list(map(lambda x : x * 2, [1,2,3,4]))  # returns [2,4,6,8]
list(map(lambda x, y : x + y, [1,2,3], [4,5,6])) # returns [5,7,9]

filter(function_object, iterable)
# function_object returns a boolean value and is called for each element of the iterable.

list(filter(lambda x : x % 2 == 0, range(5))) # returns [0,2,4]


```



### * and **

The `*args` and `**kwargs` is a common idiom to allow <u>arbitrary number</u> of arguments to functions 

The single `*` means that there can be any number of extra positional arguments

The double `**` means there can be any number of extra named parameter

The `*args` will give you all function parameters as a tuple.

The `**kwargs` will give you all **keyword arguments** except for those corresponding to a formal parameter as a dictionary.

```python
def foo(*args,**kwargs):
    for a in args:
        print(a)
    for a in kwargs:
        print(a,kwargs[a])
foo(1)      
foo(1,2,3)
foo(name='one',age=27)
```

`* ` can also used to unpack the arguments

```python
list(range(3, 6)) 
list(range(*[3,6]))

a,*b,c = [1,2,3,4]
# a: int  1
# b: list [2,3]
# c: int  4

def foo(x,y,z):
    print("x=" + str(x))
    print("y=" + str(y))
    print("z=" + str(z))
    
mylist = [1,2,3]
foo(*mylist)
mydict = {'x':1,'y':2,'z':3}
foo(**mydict)
mytuple = (1, 2, 3)
foo(*mytuple)
```



## 3. Class







```python
# example 1
class circle(object):
    def __init__(self,radius=3,color='red'):
        self.radius=radius
        self.color=color
    def add_r(self,r):
        return self.radius+r

c1=circle()
c2=c1.add_r(2)
print(c1.radius)		# 3
print(c2)						 # 5

# example 2
class circle(object):
    def __init__(self,radius=3,color='red'):
        self.radius=radius
        self.color=color
    def add_r(self,r):
        self.radius=self.radius+r

c1=circle()
c2=c1.add_r(2)
print(c1.radius)		# 5
print(c2)					 	# None

#  Find out the all the methods can be used on the object 
dir(c1)

# good to know
# Import the library
import matplotlib.pyplot as plt
%matplotlib inline  


```















## 4. Type Conversion

Python has two types of type conversion.

1. Implicit Type Conversion
    - Python automatically converts one data type to another data type. This process doesn't need any user involvement.
2. Explicit Type Conversion

```python
# int(value,base)
int("3f",16)

# Conversion from float to int will truncate the value (make it closer to zero).
int(-10.6)   # -10

```



## 5. Python Built-in



### Python Built-in Functions

In Python 3.6 (latest version), there are 68 built-in functions.



The `eval()` expression is a very powerful built-in function of Python. It helps in evaluating an expression. The expression can be a Python statement, or a code object.

`eval`(*expression*, *globals=None*, *locals=None*)

The arguments are a string and optional globals and locals. If provided,*globals* must be a dictionary. If provided, *locals* can be any mapping object.

```python
x = 1
eval('x**3 + x**2 + x + 1')
```





### Python Built-in Keyword

There are 33 keywords in Python 3.7. 



```python
import keyword
print(keyword.kwlist)
```

### 



## 6. Other good-to-know

### Multi-line statement

In Python, end of a statement is marked by a newline character. But we can make a statement extend over multiple lines with the line continuation character (\). For example:

```python
a = 1 + 2 + 3 + \
    4 + 5 + 6 + \
    7 + 8 + 9
```

This is **explicit** line continuation. In Python, line continuation is **implied** inside parentheses ( ), brackets [ ] and braces { }. For instance, we can implement the above multi-line statement as

```python
a = (1 + 2 + 3 +
    4 + 5 + 6 +
    7 + 8 + 9)

colors = ['red',
          'blue',
          'green']
```

We could also put multiple statements in a single line using semicolons, as follows

```python
a = 1; b = 2; c = 3
```



### Multi-line comments

```python
#This is a long comment
#and it extends
#to multiple lines

"""This is also a
perfect example of
multi-line comments"""
```

Another way of doing this is to use triple quotes, either `'''` or `"""`.

These triple quotes are generally used for multi-line strings. But they can be used as multi-line comment as well. Unless they are not docstrings, they do not generate any extra code.

### Docstring in Python

Docstring is short for documentation string.

It is a string that occurs as the first statement in a module, function, class, or method definition. We must write what a function/class does in the docstring.

Triple quotes are used while writing docstrings. 

Docstring is available to us as the attribute `__doc__` of the function.

```python
def double(num):
    """Function to double the value"""
    return 2*num
print(double.__doc__)
```



## 7. Python Data 

Literals:

- Numeric Literals
  - Integer: binary, decimal, octal, hexadecimal
  - Float: 10.5 and 1.5e2
  - Complex: 3.14j 
- String literals
  - unicode literal: `u"\u00dcnic\u00f6de"`
  - raw string literal: `r"raw \n string"`
- Boolean literals: `True` and `False`
- Special literals: `None`
- Literal Collections



We can use the `type()` function to know which class a variable or a value belongs to and the `isinstance()` function to check if an object belongs to a particular class.



Integers can be of **any length**, it is only limited by the memory available.

A floating point number is accurate up to 15 decimal places.

To overcome this issue, we can use decimal module that comes with Python. While floating point numbers have precision up to 15 decimal places, the decimal module has user settable precision.

```python
import decimal

print(0.1)
# Output: 0.1

print(decimal.Decimal(0.1))
# Output: Decimal('0.1000000000000000055511151231257827021181583404541015625')
```

We generally use Decimal in the following cases.

- When we are making financial applications that need **exact decimal** representation.
- When we want to control the level of **precision** required.
- When we want to implement the notion of significant decimal places.
- When we want the operations to be carried out like we did at school



Python provides operations involving fractional numbers through its `fractions` module.

A fraction has a numerator and a denominator, both of which are integers. This module has support for rational number arithmetic.



While creating Fraction from `float`, we might get some unusual results. This is due to the imperfect binary floating point number representation as discussed in the previous section.

Fortunately, Fraction allows us to instantiate with string as well. This is the preferred options when using decimal numbers.



```python
import fractions

print(fractions.Fraction(1.5))
print(fractions.Fraction(3,2))
# Output: 3/2

print(fractions.Fraction(1.1))
# Output: 2476979795053773/2251799813685248
print(fractions.Fraction('1.1'))
# Output: 11/10
```







# Part 2: Python Data Structures 

## 0. Sequence  (7 operations)

- both mutable and immutable
- `s` and `t` are sequences of the same type
- `n`, `i`, `j` and `k` are integers (index)
- `x` is an arbitrary object that meets any type and value restrictions imposed by `s`



1. `x in s` , `x not in s`
2. `s + t`, `s * n` or `n * s`
3. `s[i]`, `s[i:j]`, `s[i:j:k]`
   - `s[i:j:k]` means slice of `s` from `i` to  `j` with step `k`
4. `len(s)`
5. `min(s)`, `max(S)`
6. `s.index(x,i,j)`, `s.index(x,i)`, `s.index(x)`: first occurrence 
   - if not, raise `ValueError`
7. `s.count(x)`



Example: 

```python
print(min('abc'))

# Result:
a
```



## 0. Mutable Sequence (11 operations)

- `s` is an instance of a <u>mutable</u> sequence type
- `t` is any <u>iterable</u> object
- `x` is an arbitrary object that meets any type and value restrictions imposed by `s` 



1. `s[i] = x`, `s[i:j] = t`, `s[i:j:k] = t`
   - `t` must have the same length as the slice it is replacing
2. `del s[i:j]`, `del s[i:j:k]`
3. `s.clear()`  same as `del s[:]`
4. `s.copy()` same as `s[:]`
   - `clear()` and `copy()` are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as `dict` and `set`)
5. `s.append(x)`
6. `s.extend(t)` or `s += t`
7. `s *= n`
8. `s.insert(i, x)` same as `s[i:i] = x`
9. `s.pop([i])` retrieves the item at `i` <u>and</u> remove it from `s`
   - The optional argument `i` defaults to -1, so that by default the last item is removed and returned
10. `s.remove(x)` removes the <u>first</u> item 
    - `remove` raises `ValueError` when `x` is not found in `s`.
11. `s.reverse()`
    - It will modify `s`, not return a new sequence



## 1. List

### 1.1 To Construct a List

```python
# 1. Using square brackets, separating items with commas: 
list_11 = []   # empty list
list_12 = [a, b, c]

# 2. Using a list comprehension: [x for x in iterable]
list_2 = [x**2 for x in range(10)]

# 3. Using the type constructor: `list()` or `list(iterable)`
list_31 = list( (1, 2, 3) )
list_32 = list('abc')
print(list_31, list_32)

# 4. Many other operations also produce lists, including the sorted() built-in.

# Result:
[1, 2, 3] ['a', 'b', 'c']
```



### 1.2 Important List Operations (11)

1. `len(a)`
2. `a in [a, b, c]` returns `True`
3. `L.append()`
   - `L` is updated, returns `None`
4. `.extend(L)`, it appends all the emelents in `L`
5. `.index(x)`  (similar to tuple) it will cause an error if `a` in not in the list
6. `.remove(x)` , it will cause an error if `a` in not in the list
7. `.insert(i, x)`
8. `.pop(i=-1)`, remove the `i`th **element**, return the element 
   - `del(L[i])`
9. `.count(x)`, count how many times `x` appear in the list
10. `.reverse()` 
11. `.sort()`

```python
str1 = [1,2,3,4,5]
print(str1.pop(1))
print(str1)

# Result:
2
[1, 3, 4, 5]
```



### 1.3 More about sort()

**Lists implement all of the <u>common</u> and <u>mutable</u> sequence operations. Lists also provide the following additional method:** `.sort()`

- `sorted(L)` returns a sorted list, but not mutates `L`
- `L.sort()` mutates `L`

```python
## L.sort(key=..., reverse=...) # default is ASC
# sort by length
L = ['124','abcd','23']
L.sort(key = len)

# sort by the second character
L.sort(key = lambda x:x[1])

```



### 1.4 List Example: find the shortest element

```python
string_lst = ["some", "example", "words", "that", "i", "am", "fond", "of"]
min(string_lst, key=len)

# or just need the length
min([len(s) for s in string_lst])
```



### 1.5 List Example: find the most frequent element

```python
test = [1,2,3,4,2,2,3,1,4,4,4]
max(set(test), key=test.count)
```



## List Alias (only works when L1 = L2)

```python
###  example 1

L1 = ['MJ',1]
L2 = L1
L1.append('NEW')
print(L1)
print(L2)
print(L1 == L2)
print(L1 is L2)

L1 = ['MJ',1]
L2 = L1                 # only this is aliasing
L1 = L1 + ['NEW']		    # note: this is a new assignment 
print(L1)
print(L2)

# to clone
L1 = ['MJ',1]
L2 = L1[:]			
L1.append('NEW')
print("clone L1:", L1)
print("clone L2:", L2)


# Result:
['MJ', 1, 'NEW']
['MJ', 1, 'NEW']
True
True

['MJ', 1, 'NEW']
['MJ', 1]

clone L1: ['MJ', 1, 'NEW']
clone L2: ['MJ', 1]
```



#### Ways to clone or copy (3 ways)

| Method                                | Example          |
| ------------------------------------- | ---------------- |
| use the built-in `list.copy()` method | `L2 = L1.copy()` |
| Slice                                 | `L2 = L1[:]`     |
| use the built-in `list()` function    | `L2 = list(L1)`  |



```python
# functin example:
def flip(spins,j):
    z = spins						# note: this is aliasing, 
                       # this may change the global variable
    z[j] = z[j]-1
    return z

spin = [1,1,1]
test = flip(spin,1)
print(spin)

def flip2(spins,j):
    z = spins.copy()		   # note: this not aliasing
    z[j] = z[j]-1
    return z	

spin = [1,1,1]
test = flip2(spin,1)
print(spin)

# Result:
[1, 0, 1]
[1, 1, 1]
```



## Shallow Copy and Deep Copy

- copy using **=** operator: copy an object
- `copy.copy()`: shallow copy: 
    - created a new object with reference to the original elements
    - new appended will have no effect 
- `copy.deepcopy()`: no reference







## List Comprehension Examples 

```python
# method 1: use a loop 
squares =[]
for x in range(10):
  squares.append(x**2)
  
# method 2: use a lambda 
# map(function_to_apply, list_of_inputs), must use with list().
squares = list(map(lambda x:x**2, range(10)))

# method 3: use list comprehension
squares = [x**2 for x in range(10)]

# example 2: with condition
s2 = [(x,y) for x in [1,2,3] for y in [3,1,4] if x!= y]
print(s2)

# example 3: turn nested list to a single list
vec = [[1,2,3],[4,5,6],[7,8,9]]
s3 = [num for elem in vec for num in elem ]
print(s3)

# Result:
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```



```python
# we can also do set comprehension and dictionary comprehension
testDict = {i: i * i for i in range(10)} 
testSet = {i * 2 for i in range(10)}
```



## 2. Tuple (immutable)

### 2.1 To Construct a Tuple

Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. 

```python
# 1. Using a trailing comma for a singleton tuple: 
tuple_11 = a,
tuple_12 = (a,)
tuple_13 = ()      # empty tuple
 
# 2. Separating items with commas:
tuple_21 = a,b,c
tuple_22 = (a, b, c)

# 3. Using the type constructor: `tuple()` or `tuple(iterable)`
tuple_31 = tuple( [1, 2, 3] )
tuple_32 = tuple('abc')
print(tuple_31,tuple_32)

# Result:
(1, 2, 3) ('a', 'b', 'c')
```



**Tuples implement all of the common sequence operations**

`sorted(tuple)` will return a `list`

```python
Ratings = (0, 9, 6, 5, 10, 8, 9, 6, 2)
RatingsSorted = sorted(Ratings)
print(RatingsSorted)
print(type(RatingsSorted))

# Result:
[0, 2, 5, 6, 6, 8, 9, 9, 10]

<class 'list'>
```



## 3. Range (immutable)

- Used in `for` loop
- Used with `list()` 

- The advantage of the `range` type over a regular `list` or `tuple` is that a `range` object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the `start`, `stop` and `step` values, calculating individual items and subranges as needed).



```python
print(list(range(5)))
print(list(range(1,5)))
print(list(range(1,5,2)))

# Result:
[0, 1, 2, 3, 4]
[1, 2, 3, 4]
[1, 3]
```



## 4. Text Sequence Type - String (immutable)

### 4.1 Convert Between String and List

```python
print(list('abc'))
L =['a', 'b', 'c']
print(''.join(L))
print('_'.join(L))

# Result:
['a', 'b', 'c']
abc
a_b_c
```



### 4.2 String Methods (7 operations)



1. `s.count(sub,[start, end])`: return non-overlapping occurrences
2. `s.find(sub,[start, end])`: find the first occurence, if not, return `-1``
   - `s.rfind(sub,[start, end])`

3. `s.index(sub,[start, end])`: similar to `s.find()`, if not, cause `ValueError`
   - `s.rindex(sub,[start, end])`
4. `s.replace(old,new,[count])`
   - Can be used to remove a character, note `s` is not changed

5. `s.partition(sep)` returns a <u>tuple</u> with **three** elements
   - `s` is not changed,
   - `s.rpartition(sep)`
6. `s.split(sep=None, maxsplit=-1)`,`s` is not changed,  `sep` is removed, return a <u>list</u>
   - `s.rsplit(sep=None, maxsplit=-1)`
   - If `sep` is not specified or is `None`, a different splitting algorithm is applied. First, whitespace characters (spaces, tabs, newlines, returns, and formfeeds) are stripped from both ends. Then, words are separated by arbitrary length strings of whitespace characters. Consecutive whitespace delimiters are treated as a single delimiter
7. `s.strip([char])`: remove the leading and trailing characters.
   - Return a copy of the string with the leading and trailing characters removed. The *chars* argument is a string specifying the set of characters to be removed. If omitted or `None`, the *chars* argument defaults to removing whitespace. The *chars* argument is not a prefix or suffix; rather, all combinations of its values are stripped. 
   - `lstrip, rstrip`
8. Others:
   - `s.lower(), s.upper()`

```python
s = 'abcdabc' 
print('count:', s.count('b'))
print('find:', s.find('b'))
print('rfind:', s.rfind('b'))
print('find:', s.find('A'))
print('replcae:', s.replace('a',''))
print(s)

print('partition:', s.partition('a'))
print('1,2,3'.split(','))
print('1,2,3'.split(',', maxsplit=1))
print('1 2 3'.split())
print('   1   2   3   '.split())
print('   spacious   '.strip())
print('   spacious   '.rstrip())
print('   spacious   '.strip('s '))

# Result:
count: 2
find: 1
rfind: 5
find: -1
replcae: bcdbc
abcdabc
partition: ('', 'a', 'bcdabc')
['1', '2', '3']
['1', '2,3']
['1', '2', '3']
['1', '2', '3']
spacious
   spacious
paciou
```



```python
print('cd'.partition('cd'))
print('abef'.partition('cd'))
print('abcefd'.replace('cd', '12'))

# Result:
('', 'cd', '')
('abef', '', '')
abcefd
```

### 4.3 To Reserve a String

```python
# Using the loop:
def reverse(s):
  str = ''
  for i in s:
    str = i + str
  return str


# Using the recursion:
def reverse(s):
  if len(s) == 0:
    return s
  else:
    return reverse(s[1:]) + s[0]

# The easiest way
def reverse(s):
  return s[::-1]
```

![pic](../../../../../Desktop/nasa-1lfI7wkGWZ4-unsplash.jpg)


## 5. Set (mutable)

-  A `set `object is an <u>unordered collection</u> of distinct <u>hashable</u> objects
- The `set` type is **mutable** 
  - the contents can be changed using methods like `add()` and `remove()`.
  - Difference between `s=t` and `s=t.copy()`
- The `frozenset `type is **immutable** and hashable 
  - its contents cannot be altered after it is created
- Common uses include 
  - membership testing, 
  - removing duplicates from a sequence, and 
  - computing mathematical operations such as intersection, union, difference, and symmetric difference.

### 5.1 Set and Frozenset Operations (9)

1. `len(s)`
2. `x in s` and `x not in`
3. `s.isdisjoint(t)`
4. `s.issubset(t)`, `s <= t` , `s < t`
5. `s.issuperset(t)`, `s >= t` , `s > t`
6. `s.union(t1,t2)`, `s | t1 | t2 `
7. `s.intersection(t1,t2)`, `s & t1 & t2`
8. `s.difference(t1,t2)`, `s - t1 - t2`
9. `s.symmetric_difference(t)`, `s ^ t`: = `(s | t) - (s & t)`

```python
# the non-operator versions will accept any iterable as an argument.
print(set('abc').intersection('cbs'))
print(set('abc') & 'cbs')
print(set('abc') & set('cbs'))

# Result:
{'b', 'c'}
TypeError: unsupported operand type(s) for &: 'set' and 'str'
{'b', 'c'}
```

### 5.2 Set (mutable) Only Operations (10)

`x` is an element, `s` and `t` are sets

10. `s.update(t1,t2)`, `s |= t1 | t2`
11. `s.intersection_update(t1,t2)`, `s &= t1 & t2`
12. `s.difference_update(t1,t2)`, `s -= t1 | t2`
13. `s.symmetric_difference_update(t)`, `s ^= t`
14. `s.add(x)`
15. `s.remove(x)`: Raises `KeyError `if `x` is not contained in the set
16. `s.discard(x)`
17. `s.pop()`:  *Remove* and return an arbitrary element from the set. Raises `KeyError` if the set is empty.
18. `s.clear()`: remove all elements
19. `s.copy()`

```python
a = {1,2,3}
print(a.pop())
print(a)

print(set('abc') == frozenset('abc'))

# Result:
1
{2, 3}
True
```



## 6. Mapping Type - dict

- A mapping object maps **hashable** values to arbitrary objects. 
- Mappings are **mutable** objects. 
- There is currently only one standard mapping type, the `dictionary`. 

### 6.1 To construct a Dictionary

```python
a  = {'one': 1, 'two': 2, 'three': 3}
b  = dict(one=1, two=2, three=3)
c1 = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
c2 = dict(zip(('one', 'two', 'three'), (1, 2, 3)))
c3 = dict(zip({'one', 'two', 'three'}, {1, 2, 3}))  # note: unsorted

d1 = dict([('two', 2), ('one', 1), ('three', 3)])
d2 = dict([['two', 2], ['one', 1], ['three', 3]])

e  = dict({'three': 3, 'one': 1, 'two': 2})

f = dict.fromkeys(('key1', 'key2', 'key3'), 0) # all with value 0
print(a == b1 == c1 == c2  == d1 == d2  == e)
print(c1 == c3)

# Result:
True
False
```

###  6.2 Dictionary Operations (14)

`d` is `dict`

1. `len(d)`
2. `d[key] `: Raises a `KeyError` if key is not in the map.
   - If a subclass of `dict` defines a method `__missing__()` and key is not present, the `d[key] `operation calls that method with the key `key` as argument. 
3. `d[key]=value`: update the value
4. `key in d` and `key not in d`
5. `del d[k]`: Raises a `KeyError` if key is not in the map.
6. `iter(d)`: shortcut for `iter(d.keys())`
7. `d.clear()`
   - It will result an empty dictionary, `del d` will delete the whole dictionary
8. `d.copy()`
9. `d.items()`, `d.keys()`, `d.values()`
10. `d.get(key, [default])`
   - If `default` is given, then it will returned when `key` is not in `d`
   - Otherwise, Raises a `KeyError` 
11. `d.setdefault(key, [default])`
    - If `key` is in the dictionary, return its value. 
    - If not, insert `key` with a value of `default` and return `default`. `default` defaults to `None`.
12. `d.pop(key, [default])`: remove and return the value. 
    - If `key` is in the dictionary, remove it and return its value, else return `default`. 
    - If `default` is not given and `key` is not in the dictionary, a `KeyError` is raised.
13. `d.popitem()`
    - Remove and return a `(key, value)` pair from the dictionary. 
    - Pairs are returned in LIFO order.
    - Useful to destructively iterate over a dictionary, as often used in set algorithms. 
    - If the dictionary is empty, calling `popitem() `raises a `KeyError`.
14. `d.update([other])`
    - Update the dictionary with the key/value pairs from `other`, overwriting existing keys. 
    - Return None.
    - It accepts either another <u>dictionary</u> object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs:` d.update(red=1, blue=2)`.


```python
a  = {'one': 1, 'two': 2, 'three': 3}
b  = dict(one=1, two=2, three=3)
c1 = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
c2 = dict(zip(('one', 'two', 'three'), (1, 2, 3)))
c3 = dict(zip({'one', 'two', 'three'}, {1, 2, 3}))  # note: unsorted

d1 = dict([('two', 2), ('one', 1), ('three', 3)])
d2 = dict([['two', 2], ['one', 1], ['three', 3]])

e  = dict({'three': 3, 'one': 1, 'two': 2})

f = dict.fromkeys(('key1', 'key2', 'key3'), 0) # all with value 0
print(a == b1 == c1 == c2  == d1 == d2  == e)
print(c1 == c3)

# Result:
True
False
```

```python
d = {'person': 2, 'cat': 4, 'spider': 8}
for animal, legs in d.items():
    print('A %s has %d legs' % (animal, legs))
```



### 6.3 Dictionary view objects

The objects returned by` dict.keys()`, `dict.values()` and `dict.items()` are view objects. They provide a **dynamic** view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes.

1. `len(dictview)`
2. `iter(dictview)`
3. `x in dictview`

```python
dishes = {'eggs': 2, 'bacon': 1, 'spam': 500}
keys = dishes.keys()
values = dishes.values()

del dishes['eggs']
print(list(keys))

# Result:
['bacon', 'spam']
```



### 6.4 Loop through a dictionary



```python
# method 1:
D1 = {1:'a', 2:'b', 3:'c'} 
for k in D1.keys():
    print (k, D1[k])
    
# method 2:
D1 = {1:'a', 2:'b', 3:'c'} 
for k,v in D1.items():
    print (k,v)
```

```python

```

```python
it
```


```sh
di
```


```python
import os
hello = 'q'
```

  
console.log('');

abc a ****

a c console.log('');
```python
import os
```



```sh
cd ----
```


```python
a = [1,2,3]
b = [1,2,3]
```



1 UP
up123   

up to 15 decimal place

```python

```

```shell
cd luohao

```

console.log('tis is for fun');

```'python|shell'

```

```shell

```

```'${1|python,shell}'

```


## 7. Other Objects

### 7.1 The Null Object

This object is returned by functions that don’t explicitly return a value.

It is written as `None`.
![](nasa-1lfI7wkGWZ4-unsplash.jpg)
### 7.2 The Ellipsis Object

This object is commonly used by slicing.

It is written as `Ellipsis` or `...`.

### 7.3 The NotImplemented Object

This object is returned from comparisons and binary operations when they are asked to operate on types they don’t support.

It is written as `NotImplemented`.



















## 11. Counter 

- A `Counter` is a `dict` subclass for counting hashable objects. 
- It is a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. 
- Counts are allowed to be any integer value including zero or negative counts. 
- The `Counter` class is similar to bags or multisets in other languages.

### 11.1 To Create a Counter

```python
from collections import Counter

# a new, empty counter
c = Counter()                           
# a new counter from an iterable
c1 = Counter('gallahad')                 
# a new counter from a mapping
c2 = Counter({'red': 4, 'blue': 2})      
# a new counter from keyword args
c3 = Counter(cats=4, dogs=8)             
```



```python
# count of a missing element is zero
print(c1['c'])
# Setting a count to zero does not remove an element from a counter. Use del to remove it entirely
print(c1)
c1['a'] = 0
print(c1)
del c1['a']
print(c1)

# Result:
0
Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})
Counter({'l': 2, 'g': 1, 'h': 1, 'd': 1, 'a': 0})
Counter({'l': 2, 'g': 1, 'h': 1, 'd': 1})
```



### 11.2 Counter Operations 



1. Since it is a `dict`,

   -  `c.keys(), c.values(), c,items(), c.clear(),`

2. `c.elements()` returns an iterator

   1. If an element’s count is less than one, `elements()` will ignore it.

   - `list(c.elements())`
   - `sorted(c.elements())`

3. `c.most_common([n])`

   - Return a list of the `n` most common elements and their counts from the most common to the least. If `n` is omitted or `None`, `most_common() `returns all elements in the counter. Elements with equal counts are ordered arbitrarily
   - For least common, just reverse the list, `c.most_common([n])[::-1]` 

4. `subtract([iterable-or-mapping])`

   - Like `dict.update()` but subtracts counts instead of replacing them.

5. Mathematic operations

   - Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less.
   - Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. 
   - **Intersection** and union return the minimum and maximum of corresponding counts.
   - Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter.



```python
c = Counter(a=4, b=2, c=0, d=-2)
print(list(c.elements()))
print(c.most_common(2))

c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
c.subtract(d)
print('subtract:', c)
c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
print('c+d:',c+d)
print('c-d:',c-d)
print('c&d:',c&d)
print('c|d:',c|d)
print('+c: ',+c)
print('-c: ',-c)

# Result:
['a', 'a', 'a', 'a', 'b', 'b']
[('a', 4), ('b', 2)]
subtract: Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})
c+d: Counter({'a': 5, 'b': 4, 'c': 3, 'd': 2})
c-d: Counter({'a': 3})
c&d: Counter({'b': 2, 'a': 1})
c|d: Counter({'a': 4, 'd': 4, 'c': 3, 'b': 2})
+c:  Counter({'a': 4, 'b': 2})
-c:  Counter({'d': 2})
```



```python
sum(c.values())                 # total of all counts
c.clear()                       # reset all counts
list(c)                         # list unique elements
set(c)                          # convert to a set
dict(c)                         # convert to a regular dictionary
c.items()                       # convert to a list of (elem, cnt) pairs
Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs
c.most_common()[:-n-1:-1]       # n least common elements
+c                              # remove zero and negative counts
```







# Part 3: Python Interview Problems

## Some tips:

1. When there is a duplicate, think about the “set"
2. to quickly swap two variable, using tuple

```python
(x, y) = (y, x)
x, y = y, x

# for same value
x = y = z = 1
```



3. Ternary Operator 

```python
[on_true] if [expression] else [on_false]
# Example: 
x = 10 if (y == 9) else 20
x = (classA if y == 1 else classB)(param1, param2)
# classA and classB are two classes and one of the class constructors would get called
# can use together with list comprehension
[x+1 if x%2 == 0 else x for x in range(10)]
```



## Common Gotchas #1: Mutable Default Arguments

Python’s default arguments are evaluated *once* when the function is defined, not each time the function is called (like it is in say, Ruby). This means that if you use a mutable default argument and mutate it, you *will* and have mutated that object for all future calls to the function as well.

```python
# example:
def append_to(element, to=[]):
    to.append(element)
    return to
  
# print
my_list = append_to(12)
print(my_list)

my_other_list = append_to(42)
print(my_other_list)

# result
[12]
[12, 42]

# CORRECT WAY
def append_to(element, to=None):
    if to is None:
        to = []
    to.append(element)
    return to
```









## Division

```python
print(3/2)
print(3//2)
print(2.5/2)
print(2.5//2)

# Result:
1.5
1
1.25
1.0
```



## Boolean - False

When the expressions are used in control flow statements: these are interpreted as `False`:

- `False, None`
- Numerical zero of all types (0, 0.0, 0+0j)
- Empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets)



## == vs is

- `==` test equality
- `is` test identity

```python
1 == 1     # True
a = [1,2]
b = [1,2]
a == b     # True
a is b     # False
```



## math package:

```python
import math
math.factorial(5)

print(math.ceil(2.5))
print(math.floor(2.5))

# Result:
3
2
```



# Part 4: Efficiency





## Complexity of Common Python Functions:



list vs deque

| Operation                  | list   | deque  |                   |
| -------------------------- | ------ | ------ | ----------------- |
| Index, get item, set item, | $O(1)$ |        |                   |
| length                     | $O(1)$ |        |                   |
| append[1]                  | $O(1)$ | $O(1)$ | deque: appendleft |
|                            |        |        |                   |
| pop[-1]                    | $O(1)$ |        | deque: popleft    |
| pop[immediate]             | $O(n)$ |        |                   |
| copy item                  | $O(n)$ | $O(n)$ |                   |
| insert item                | $O(n)$ |        |                   |
| delete item                | $O(n)$ |        |                   |



- LIST: $n$ is $len(L)$ 
  - $O(1)$: index, store, length, append
  - $O(n)$: ==, REMOVE, COPY, REVERSE, ITERATION, IN LIST
  - $O(n\log n)$: sort
- Dictionaries: $n$ is $len(d)$
  - Worst case: $O(n)$: index, store, length, delete, iteration
  - Average Case: $O(1)$: index, store, delete; $O(n)$: iteration

## Measure with Timer

- Use module `datetime.datetime`

```python
import datetime

t0 = datetime.datetime.now()
# call function
t1 = datetime.datetime.now() - t0
```



```python
import time
tick = time.time()
# call function
time_to_completion = time.time() - tick
```



- Express in terms of the size of <u>input</u>

- Different inputs change how the program runs:

  - Best case
  - Average case
  - Worse case -> focus

- Big Oh notation $O()$:

  - Ignore the additive constants or multiplicative constants

  - e.g. if steps = `1+5n+1`, then it is $O(n)$

  - Focus on **dominant terms**:

    - #### $\log(n) < n < n \log(n) < n^2 < 2^n <e^n$

    - **Law of Addition**:  $O(n) + O(n^2) =O(n+n^2) =O(n^2)  $

    - **Law of Multiplication **:  $O(n) * O(n) =O(n*n) =O(n^2)  $



- Linear Search on UNSORTED List:
  - Constant time list access

```python
def linear_search(L, e):
    found = False
    for i in range(len(L)):
        if e == L[i]:
            found = True
    return found
```

$O(1+4n+1) =O(n) \quad where \ n = len(L) $



- Linear Search on SORTED List:

```python
def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True
        if L[i] > e:
            return False
    return False
```

$O(n)$



## Logarithmic Complexity:

Assuming `L` is sorted list

```python
def bisect_search1(L, e):
    return L == []:
        return False
    elif (L) == 1:
        return L[0] == e
    else:
      	half = len(L)//2
        if L[half] > e:
          		return bisect_search1( L[:half], e)
        else:
          		return bisect_search1( L[half:], e)
```

Worst case: $n = 2^i $  -> $ i = \log(n)$

- $O(\log(n))  $ Bisection search calls
- $O(n) $ For each bisection search calls to **copy** the list `L[:half]`
- $O(\log (n)) * O(n) =  O(n \log {(n)})$

Better Solution:

```python
def bisect_search2(L, e):
    def bisect_search_helper(L, e, low, high):
        print('low: ' + str(low) + '; high: ' + str(high))  #added to visualize
        if high == low:
            return L[low] == e
        mid = (low + high)//2
        if L[mid] == e:
            return True
        elif L[mid] > e:
            if low == mid: #nothing left to search
                return False
            else:
                return bisect_search_helper(L, e, low, mid - 1)
        else:
            return bisect_search_helper(L, e, mid + 1, high)
    if len(L) == 0:
        return False
    else:
        return bisect_search_helper(L, e, 0, len(L) - 1)
```

$O(\log(n))  * O(1) = O(\log(n)) $

## Exponential Complexity

```python
def genSubsets(L):
    res = []
    if len(L) == 0:
        return [[]] #list of empty list
    smaller = genSubsets(L[:-1]) # all subsets without last element
    extra = L[-1:] # create a list of just last element
    new = []
    for small in smaller:
        new.append(small+extra)  # for all smaller solutions, add one with last element
    return smaller+new  # combine those with last element and those without
```

$ O(2^n) $

- let $t_n$ denote time to solve problem of size $n$
- let $s_n$ denote size of solution for problem of size $n$
- Then $t_n = t_{n-1}+s_{n-1}+c =t_{n-1}+2^{n-1}+c = \ldots = 1+ 2^n+nc$ 



# Part 5: Sort & Search Algorithm

- Monkey Sort, permutation sort, $O(n!)$

http://pythontutor.com/visualize.html#mode=edit

## Bubble Sort:

It is a comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order.

```python
def bubblesort(list):
    for iter_num in range(len(list)-1,0,-1):
        for idx in range(iter_num):
            if list[idx]>list[idx+1]:
                list[idx], list[idx+1] = list[idx+1], list[idx]

list = [19,2,31,45,6,11,121,27]
bubblesort(list)
```

$O(n) * O(n) = O(n^2)$



## Insertion Sort

Insertion sort involves finding the right place for a given element in a sorted list. So in beginning we compare the first two elements and sort them by comparing them. Then we pick the third element and find its proper position among the previous two sorted elements. This way we gradually go on adding more elements to the already sorted list by putting them in their proper position.

```python
def insertion_sort(InputList):
    for i in range(1, len(InputList)):
        j = i-1
        nxt_element = InputList[i]
# Compare the current element with next one
		
        while (InputList[j] > nxt_element) and (j >= 0):
            InputList[j+1] = InputList[j]
            j=j-1
        InputList[j+1] = nxt_element

list = [19,2,31,45,30,11,121,27]
insertion_sort(list)
print(list)
```





## Shell Sort

Shell Sort involves sorting elements which are away from each other. We sort a large sublist of a given list and go on reducing the size of the list until all elements are sorted. The below program finds the gap by equating it to half of the length of the list size and then starts sorting all elements in it. Then we keep resetting the gap until the entire list is sorted.

```python

```



## Selection Sort:

```python
def selection_sort(L):
    suffixSt = 0
    while suffixSt != len(L):
        print('selection sort: ' + str(L))
        for i in range(suffixSt, len(L)):
            if L[i] < L[suffixSt]:
                L[suffixSt], L[i] = L[i], L[suffixSt]		# swap
        suffixSt += 1
```

$O(n) * O(n) = O(n^2)$



## Merge sort:

Merge sort first divides the array into equal halves and then combines them in a sorted manner.

```python
def merge_sort(unsorted_list):
    if len(unsorted_list) <= 1:
        return unsorted_list

    middle = len(unsorted_list) // 2
    left_list = unsorted_list[:middle]
    right_list = unsorted_list[middle:]

    left_list = merge_sort(left_list)
    right_list = merge_sort(right_list)
    return merge(left_list, right_list)

def merge(left_half,right_half):

    res = []
    while len(left_half) != 0 and len(right_half) != 0:
        if left_half[0] < right_half[0]:
            res.append(left_half[0])
            left_half.remove(left_half[0])
        else:
            res.append(right_half[0])
            right_half.remove(right_half[0])
    res = res + right_half if len(left_half) == 0 else res + left_half
    return res

unsorted_list = [64, 34, 25, 12, 22, 11, 90]
print(merge_sort(unsorted_list))
```

- For Merge:
- $O(len(left)+len(right))$ Copied the elements
- $O(len(longer \ list))$ Comparisons 
- In total: 
- Divide $O(\log(n))$,Merge: $O(n) $ , in tital: $O(n\log(n))$





# Part 6: Advanced Data Structure

Most based on 

https://www.tutorialspoint.com/python_data_structure/index.htm

## 0. Interoduction

### Linear Data Structures

These are the data structures which store the data elements in a sequential manner.

- **Array:** It is a sequential arrangement of data elements paired with the index of the data element.
- **Linked List:** Each data element contains a link to another element along with the data present in it.
- **Stack:** It is a data structure which follows only to specific order of operation. **LIFO**(last in First Out).
- **Queue:** It is similar to Stack but the order of operation is only **FIFO**(First In First Out).
- **Matrix:** It is two dimensional data structure in which the data element is referred by a pair of indices.



### Non-Linear Data Structures

These are the data structures in which there is no sequential linking of data elements. Any pair or group of data elements can be linked to each other and can be accessed without a strict sequence.

- **Binary Tree:** It is a data structure where each data element can be connected to maximum two other data elements and it starts with a root node.
- **Heap:** It is a special case of Tree data structure where the data in the parent node is either strictly greater than/ equal to the child nodes or strictly less than it’s child nodes.
- **Hash Table:** It is a data structure which is made of arrays associated with each other using a hash function. It retrieves values using keys rather than index from a data element.
- **Graph: **It is an arrangement of vertices and nodes where some of the nodes are connected to each other through links.



### Python Specific Data Structures

These data structures are specific to python language and they give greater flexibility in storing different types of data and faster processing in python environment.

- **List:** It is similar to array with the exception that the data elements can be of different data types. You can have both numeric and string data in a python list.
- **Tuple:** Tuples are similar to lists but they are <u>immutable</u> which means the values in a tuple cannot be modified they can only be read.
- **Dictionary:** The dictionary contains <u>Key-value pairs</u> as its data elements.





## 1. Node

```python
class Node:
    def __init__(self, dataval=None):
        self.dataval = dataval
        self.nextval = None

e1 = Node('Mon')
e2 = Node('Tue')
e3 = Node('Wed')

e1.nextval = e2
e3.nextval = e3
```

- Traversing the Nodes Elements: using a `while` loop

```python
thisvalue = e1

while thisvalue:
        print(thisvalue.dataval)
        thisvalue = thisvalue.nextval
```

```
Mon
Tue
Wed
```



## 2. Singly Linked List

Given the node:

```python
class Node:
    def __init__(self, dataval=None):
        self.dataval = dataval
        self.nextval = None

e1 = Node('Mon')
e2 = Node('Tue')
e3 = Node('Wed')

e1.nextval = e2
e2.nextval = e3
```



### Creating and Traversing:

```python
class SLinkedList:
    def __init__(self):
        self.headval = None

    def listprint(self):
        printval = self.headval
        while printval:
            print(printval.dataval)
            printval = printval.nextval

# Link nodes
list1 = SLinkedList()
list1.headval = e1


list1.listprint()
```

Result:

```
Mon
Tue
Wed
```



### Insertion and Remove

```python
class SLinkedList:
    def __init__(self):
        self.headval = None
        
    def listprint(self):
        printval = self.headval
        while printval:
            print(printval.dataval)
            printval = printval.nextval
            
    def atBegining(self,newdata):
        NewNode = Node(newdata)
        NewNode.nextval = self.headval
        self.headval = NewNode
        
    def atEnd(self, newdata):
        NewNode = Node(newdata)
        if self.headval is None:
            self.headval = NewNode
            return
        laste = self.headval
        while(laste.nextval):
            laste = laste.nextval
        laste.nextval=NewNode
        
    def inBetween(self,middle_node,newdata):
        if middle_node is None:
            print("The mentioned node is absent")
            return
        NewNode = Node(newdata)
        NewNode.nextval = middle_node.nextval
        middle_node.nextval = NewNode
        
    def removeNode(self, Removekey):
        HeadVal = self.headval
        if (HeadVal is None):
            return
        if (HeadVal is not None):
            if (HeadVal.dataval == Removekey):
                self.headval = HeadVal.nextval
                HeadVal = None
                return
        while (HeadVal is not None):
            if (HeadVal.dataval == Removekey):
                break
            prev = HeadVal
            HeadVal = HeadVal.nextval

        prev.nextval = HeadVal.nextval
        
list1 = SLinkedList()
list1.headval = e1
list1.atBegining("Sun")
print('At Beginning:')
list1.listprint()

list1.atEnd("Thu")
print('At the End:')
list1.listprint()

list1.inBetween(list1.headval.nextval,"Fri")
print('In Between:')
list1.listprint()
```

Result:

```python
At Beginning:
Sun
Mon
Tue
Wed
At the End:
Sun
Mon
Tue
Wed
Thu
In Between:
Sun
Mon
Fri
Tue
Wed
Thu
```



```python
list1 = SLinkedList()
list1.headval = e1
e1.nextval = e2
e2.nextval = e3
list1.removeNode("Mon")
list1.listprint()

print()

list1 = SLinkedList()
list1.headval = e1
e1.nextval = e2
e2.nextval = e3
list1.removeNode("Tue")
list1.listprint()

print()

list1 = SLinkedList()
list1.headval = e1
e1.nextval = e2
e2.nextval = e3
list1.removeNode("Wed")
list1.listprint()
```

```
Tue
Wed

Mon
Wed

Mon
Tue
```



## 3. Stack: (LIFO) Last In First Out

```python
class Stack:
    def __init__(self):
        self.stack = []
# Use list append method to add element
    def add(self, dataval):
        if dataval not in self.stack:
            self.stack.append(dataval)
            return True
        else:
            return False        
# Use list pop method to remove element
    def remove(self):
        if len(self.stack) <= 0:
            return ("No element in the Stack")
        else:
            return self.stack.pop()     
# Use peek to look at the top of the stack
    def peek(self):     
	    return self.stack[-1]

AStack = Stack()
AStack.add("Mon")
AStack.add("Tue")
AStack.peek()
print(AStack.peek())
AStack.add("Wed")
AStack.add("Thu")
print(AStack.peek())

print('Removed:' + AStack.remove())
print(AStack.peek())
```

Result:

```python
Tue
Thu
Removed:Thu
Wed
```



## 4. Queue: (FIFO) First In First Out

```python
class Queue:
  def __init__(self):
      self.queue = []
# Insert method to add element
  def addtoq(self,dataval):
      if dataval not in self.queue:
          self.queue.insert(0,dataval)
          return True
      return False
# Pop method to remove element
  def removefromq(self):
      if len(self.queue)>0:
          return self.queue.pop()
      return ("No elements in Queue!")
  def size(self):
      return len(self.queue)

TheQueue = Queue()
TheQueue.addtoq("Mon")
TheQueue.addtoq("Tue")
TheQueue.addtoq("Wed")
print(TheQueue.size())

print('Removed: ' + TheQueue.removefromq())
print(TheQueue.size())

```

Result:

```python
3
Removed: Mon
2
```



## 5. Deque: Double-ended queue

Deques are a generalization of stacks and queues (the name is pronounced “deck” and is short for “double-ended queue”). Deques support thread-safe, memory efficient appends and pops from either **side** of the deque with approximately the same O(1) performance in either direction.

Though `list` objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for `pop(0)`and `insert(0, v)` operations which change both the size and position of the underlying data representation.

```python
from collections import deque

dq = deque(['Mon','Tue','Wed'])

dq.append('Thu')
dq.appendleft('Sun')
print(dq)

dq.pop()
dq.popleft()
print(dq)
```

*class* `collections.``deque`([*iterable*[, *maxlen*]])

Common Methods:

1. append(x), appendleft(x)
2. pop(), popleft()
3. extend(iterable), extendleft(iterable)
4. index(x,i,j)
5. count(x)
6. insert(i, x)
7. remove(x) # remove teh first occurance, error if x is not found
8. reverse()
9. rotate(n=1) # rotate to the right if n is positive
10. clear()
11. copy()





## 6. Doubly Linked List

- Doubly Linked List contains a link element called <u>first</u> and <u>last</u>.
- Each link carries a data field(s) and two link fields called <u>next</u> and <u>prev</u>.
- Each link is linked with its next link using its next link.
- Each link is linked with its previous link using its previous link.
- The last link carries a link as null to mark the end of the list.



```python
class Node:
   def __init__(self, data):
      self.data = data
      self.next = None
      self.prev = None

class doubly_linked_list:
   def __init__(self):
      self.head = None
# Define the push method to add elements at the begining
   def push(self, NewVal):
      NewNode = Node(NewVal)
      NewNode.next = self.head
      if self.head is not None:
         self.head.prev = NewNode
      self.head = NewNode
# Define the append method to add elements at the end
   def append(self, NewVal):
      NewNode = Node(NewVal)
      NewNode.next = None
      if self.head is None:
         NewNode.prev = None
         self.head = NewNode
         return
      last = self.head
      while (last.next is not None):
         last = last.next
      last.next = NewNode
      NewNode.prev = last
      return
# Define the insert method to insert the element		
   def insert(self, prev_node, NewVal):
      if prev_node is None:
         return
      NewNode = Node(NewVal)
      NewNode.next = prev_node.next
      prev_node.next = NewNode
      NewNode.prev = prev_node
      if NewNode.next is not None:
         NewNode.next.prev = NewNode
# Print the Doubly Linked list		
   def listprint(self, node):
      while (node is not None):
         print(node.data),
         last = node
         node = node.next

dllist = doubly_linked_list()
dllist.push(12)
dllist.push(8)
dllist.push(62)

print('PUSH - at the beginning')
dllist.listprint(dllist.head)

print('INSERT - in the middle')
dllist.insert(dllist.head.next, 13)
dllist.listprint(dllist.head)

print('APPEND - at the end')
dllist.append(45)
dllist.listprint(dllist.head)
```

Result:

```python
PUSH - at the beginning
62
8
12
INSERT - in the middle
62
8
13
12
APPEND - at the end
62
8
13
12
45
```



## 7. Hash Table

- Hash tables are a type of data structure in which the address or the <u>index</u> value of the data element is generated from a **hash function**.
- That makes accessing the data faster as the index value behaves as a key for the data value.
- In other words, Hash table stores key-value pairs but the key is generated through a hashing function.
- So the search and insertion function of a data element becomes much faster as the key values themselves become the index of the array which stores the data.
- In Python, the Dictionary data types represent the implementation of hash tables. The Keys in the dictionary satisfy the following requirements.
  - The keys of the dictionary are hashable i.e. the are generated by hashing function which generates unique result for each unique value supplied to the hash function.
  - The order of data elements in a dictionary is not fixed.



## 8. Binary Search Tree (BST)

- A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties − The left sub-tree of a node has a key less than or equal to its parent node's key. The right sub-tree of a node has a key greater than to its parent node's key. 
- `left_subtree (keys)  ≤  node (key)  <  right_subtree (keys)`
- For duplicates, maybe it is better to have a counter.
- Tree represents the nodes connected by edges. It is a non-linear data structure. It has the following properties.
  - One node is marked as Root node.
  - Every node other than the root is associated with one parent node.
  - Each node can have an arbiatry number of chid node.
- Insert into a tree
  - The insert class **compares** the value of the node to the parent node and decides to add it as a left node or a right node. 

```python
class Node:
    def __init__(self, data):
        self.left = None
        self.right = None
        self.data = data
        
# Use the insert method to add nodes
# Compare the new value with the parent node
    def insert(self, data):
        if self.data:
            if data < self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data > self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

            
# findval method to compare the value with nodes
    def findval(self, lkpval):
        if lkpval < self.data:
            if self.left is None:
                return str(lkpval)+" Not Found"
            return self.left.findval(lkpval)
        elif lkpval > self.data:
            if self.right is None:
                return str(lkpval)+" Not Found"
            return self.right.findval(lkpval)
        else:
            print(str(self.data) + ' is found')
            
# Print the tree by METHOD, using InOrder
    def PrintTree(self):
        if self.left:
            self.left.PrintTree()
        print(self.data)
        if self.right:
            self.right.PrintTree()
            
            
# Inorder traversal
# Left -> Root -> Right
    def inorderTraversal(self, root):
        res = []
        if root:
            res = self.inorderTraversal(root.left)
            res.append(root.data)
            res = res + self.inorderTraversal(root.right)
        return res

# Preorder traversal
# Root -> Left ->Right
    def PreorderTraversal(self, root):
        res = []
        if root:
            res.append(root.data)
            res = res + self.PreorderTraversal(root.left)
            res = res + self.PreorderTraversal(root.right)
        return res

# Postorder traversal
# Left ->Right -> Root
    def PostorderTraversal(self, root):
        res = []
        if root:
            res = self.PostorderTraversal(root.left)
            res = res + self.PostorderTraversal(root.right)
            res.append(root.data)
        return res

root = Node(10)

print('Insert Result: ')
root.insert(6)
root.insert(14)
root.insert(3)
root.PrintTree()

print('Search: ')
print(root.findval(7))
print(root.findval(14))
```

Result:

```python
Insert Result: 
3
6
10
14
Search: 
7 Not Found
14 is found
None
```



```python
print(root.inorderTraversal(root))

print(root.PreorderTraversal(root))

print(root.PostorderTraversal(root))
```



```python
# A function to do inorder tree traversal 
def printInorder(root):   
    if root: 
        printInorder(root.left) 
        print(root.data)
        printInorder(root.right) 

# A function to do preorder tree traversal 
def printPreorder(root):  
    if root: 
        print(root.data)
        printPreorder(root.left) 
        printPreorder(root.right) 
        
# A function to do postorder tree traversal 
def printPostorder(root):   
    if root: 
        printPostorder(root.left) 
        printPostorder(root.right) 
        print(root.data)
```

```
inorder:
3
6
10
14

preorder
10
6
3
14

postorder
3
6
14
10
```



## Tree Traversals (Inorder, Preorder and Postorder)

this part is from https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/

![Example Tree](https://media.geeksforgeeks.org/wp-content/cdn-uploads/2009/06/tree12.gif)

Depth First Traversals:
(a) Inorder (Left, Root, Right) : 4 2 5 1 3
(b) Preorder (Root, Left, Right) : 1 2 4 5 3
(c) Postorder (Left, Right, Root) : 4 5 2 3 1

```
Algorithm Inorder(tree)
   1. Traverse the left subtree, i.e., call Inorder(left-subtree)
   2. Visit the root.
   3. Traverse the right subtree, i.e., call Inorder(right-subtree)
```

```
Algorithm Preorder(tree)
   1. Visit the root.
   2. Traverse the left subtree, i.e., call Preorder(left-subtree)
   3. Traverse the right subtree, i.e., call Preorder(right-subtree) 
```

```
Algorithm Postorder(tree)
   1. Traverse the left subtree, i.e., call Postorder(left-subtree)
   2. Traverse the right subtree, i.e., call Postorder(right-subtree)
   3. Visit the root.
```



## 9. Heap

**Min-Heap** − Where the value of the root node is **less than** or equal to either of its children.

**Max-Heap** − Where the value of the root node is greater than or equal to either of its children.



### Max Heap Construction Algorithm

```
Step 1 − Create a new node at the end of heap.
Step 2 − Assign new value to the node.
Step 3 − Compare the value of this child node with its parent.
Step 4 − If value of parent is less than child, then swap them.
Step 5 − Repeat step 3 & 4 until Heap property holds.
```

![Max Heap Animated Example](https://www.tutorialspoint.com/data_structures_algorithms/images/max_heap_animation.gif)



### Max Heap Deletion Algorithm

Deletion in Max (or Min) Heap always happens at the **root** to remove the Maximum (or minimum) value.

```
Step 1 − Remove root node.
Step 2 − Move the last element of last level to root.
Step 3 − Compare the value of this child node with its parent.
Step 4 − If value of parent is less than child, then swap them.
Step 5 − Repeat step 3 & 4 until Heap property holds.
```

![Max Heap Deletion Animated Example](https://www.tutorialspoint.com/data_structures_algorithms/images/max_heap_deletion_animation.gif)



- **Min Heap**: each parent node is less than or equal to its child node
  - `heap[k] <= heap[2*k+1] `and `heap[k] <= heap[2*k+2]` for all `k`, counting elements from zero.
    - To find Min, it is $O(\log n)$
- Max Heap: each parent node is greater than or equal to its child node
- A heap is created by using python’s inbuilt library named `heapq`. This library has the relevant functions to carry out various operations on heap data structure. Below is a list of these functions:
  - `heapify`: convert regular list to a heap
    - In the resulting heap the smallest element gets pushed to the index position 0. 
    - It works by checking if the smallest child node is less than the node itself, then swapping it and calling heapify recursively on it.
    - From top
  - `heappush`: add an element to the heap without altering the current heap
  - `heappop`: return the smallest element from the heap and remove it form the heap
  - `heapreplace`: replace the smallest data element with a new value supplied in the function
- **While a binary heap is a binary tree, it is not necessarily a binary search tree.**

```python
import heapq


H = [21,1,45,78,3,5]
heapq.heapify(H)
print(H)

print('SMALLEST')
print(H[0])

print('PUSH')
heapq.heappush(H,8)
print(H)

print('POP')
print(heapq.heappop(H))
print(H)

print('REPLACE')
heapq.heapreplace(H,6)
print(H)
```

Result:

```python
[1, 3, 5, 78, 21, 45]
SMALLEST
1
PUSH
[1, 3, 5, 78, 21, 45, 8]
POP
1
[3, 8, 5, 78, 21, 45]
REPLACE
[5, 8, 6, 78, 21, 45]
```



## 10. Graph









## 12. ChainMap

Python Maps also called ChainMap is a type of data structure to manage multiple dictionaries together as one unit. The **combined dictionary** contains the key and value pairs in a specific sequence eliminating any duplicate keys. The best use of ChainMap is to search through multiple dictionaries at a time and get the proper key-value pair mapping. We also see that these ChainMaps behave as stack data structure.



#### Creating a ChainMap

We create two dictionaries and club them using the ChainMap method from the collections library. Then we print the keys and values of the result of the combination of the dictionaries. If there are *duplicate* keys, then only the value from the <u>first key</u> is preserved.

```python
from collections import ChainMap

dict1 = {'day1': 'Mon', 'day2': 'Tue'}
dict2 = {'day3': 'Wed', 'day1': 'Thu'}

new = ChainMap(dict1,dict2)

print(list(new.keys()))
# ['day3', 'day1', 'day2']


```



#### Updating ChianMap

When the element of the dictionary is updated, the result is **instantly** updated in the result of the ChainMap. In the below example we see that the new updated value reflects in the result without explicitly applying the ChainMap method again.

```python
dict2['day3'] = 'Wednesday'

print(list(new.items()))
# [('day3', 'Wednesday'), ('day1', 'Mon'), ('day2', 'Tue')]
```








# Part 7: Python Specific

## 1. String Formating

### 1.1 Old: String Modulo Operator:

- Format: `%[flags][width][.precision]type`
  - `%6.2f`  is minimal 6 length
    - `23.789 -> 23.79`
    - `23 -> 23.00`
    - `1234.17-> 1234.17`
  - Common Type:
    - `d, i`: signed integer decimal
    - `e, E`: floating point exponential format (lowercase / uppercse)
    - `f, F`: floating point decimal format
    - `c`: string character (accepting integer or single string character)
    - `r`: string (convert any python object using `repr()`)
    - `s`: string (convert any python object using `str()`)
  - Common Flag:
    - `0`: zeroes will be padded for numeric values
    - `-`: left adjusted
    - ` (space)`:  a blank space is inserted if there is no minus sign
    - `+`: a sign character will precede the conversion



### 1.2 Better: String Format Method

- With new style formatting it is possible to give placeholders an explicit positional index.
- Unfortunately **the default alignment** differs between old and new style formatting. The old style defaults to right aligned while for new style it's left.
- New style formatting surpasses the old variant by providing more control over how values are padded and aligned. 
  - You are able to choose the padding character:
  - And also center align values, When using center alignment where the length of the string leads to an uneven split of the padding characters the extra character will be placed on the right side:
  - 

`String {field_name:conversion} Example.format(value)`

```python
<   :  left-align text in the field
^   :  center text in the field
>   :  right-align text in the field
```



| Old                          | New                              | Output             |
| ---------------------------- | -------------------------------- | ------------------ |
| `'%s %s' % ('one', 'two')`   | `'{} {}'.format('one', 'two')`   | `one two`          |
| `'%d %d' % (1, 2)`           | `'{} {}'.format(1, 2)`           | `1 2`              |
| N.A.                         | `'{1} {0}'.format('one', 'two')` | `two one`          |
| `'%10s' % ('test',)`         | `'{:>10}'.format('test')`        | test               |
| `'%-10s' % ('test',)`        | `'{:10}'.format('test')`         | test             _ |
| N.A.                         | `'{:_<10}'.format('test')`       | `text______`       |
| N.A.                         | `'{:^6}'.format('zip')`          | `_zip__`           |
| `'%.5s' % ('xylophone',)`    | `'{:.5}'.format('xylophone')`    | `xylop`            |
| `'%-10.5s' % ('xylophone',)` | `'{:10.5}'.format('xylophone')`  | xylop              |

```python
print("{gfg} is a {0} science portal for {1}".format("computer", "geeks", gfg ="GeeksforGeeks")) 
print('{0:-2%}'.format(1.0 / 3))
```



| Old                               | New                                    | Output   |
| --------------------------------- | -------------------------------------- | -------- |
| `'%06.2f' % (3.141592653589793,)` | `'{:06.2f}'.format(3.141592653589793)` | `003.14` |
| `'%+d' % (42,)`                   | `'{:+d}'.format(42)`                   | `+42`    |
| `'% d' % ((-23),)`                | `'{: d}'.format((-23))`                | `-23`    |
| `'% d' % (42,)`                   | `'{: d}'.format(42)`                   | 42       |
| N.A                               | `'{:=5d}'.format((-23))`               | `-  23`  |
| N.A                               | `'{:=+5d}'.format(23)`                 | `+  23`  |

`data = {'first': 'Hodor', 'last': 'Hodor!'}`

`person = {'first': 'J', 'last': 'Pd'}`

```python
class Plant(object):
    type = 'tree'
```

- `.format() `also accepts keyword arguments.
- New style formatting allows even greater flexibility in accessing nested data structures.
  - It supports accessing containers that support `__getitem__` like for example dictionaries and lists
  - As well as accessing attributes on objects via `getattr()`

| Old                           | New                                             | Output         |
| ----------------------------- | ----------------------------------------------- | -------------- |
| `'%(first)s %(last)s' % data` | `'{first} {last}'.format(**data)`               | `Hodor Hodor!` |
| N.A.                          | `'{first} {last}'.format(first='H', last='H!')` | `H H!`         |
| N.A.                          | `'{p[first]} {p[last]}'.format(p=person)`       | `J Pd`         |
| N.A.                          | `'{d[1]} {d[2]}'.format(d=[4, 8, 15])`          | `8 15`         |
| N.A.                          | `'{p.type}'.format(p=Plant())`                  | `tree`         |



```python
# Datetime (only new)
from datetime import datetime
print('{:%Y-%m-%d %H:%M}'.format(datetime(2001, 2, 3, 4, 5)))
# 2001-02-03 04:05


# Parametrized formats
print('{:{align}{width}}'.format('test', align='^', width='10'))
#    test   

# Parametrized precision (both)
print('%.*s = %.*f' % (3, 'Gibberish', 3, 2.7182))
print('{:.{prec}} = {:.{prec}f}'.format('Gibberish', 2.7182, prec=3))
print('{:{prec}} = {:{prec}f}'.format('Gibberish', 2.7182, prec='.3'))   # only new
# Gib = 2.718

# Width and precision (both)
print('%*.*f' % (5, 2, 2.7182))
print('{:{width}.{prec}f}'.format(2.7182, width=5, prec=2))
#  2.72

# only new
print('{:{}{}{}.{}}'.format(2.7182818284, '>', '+', 10, 3))
print('{:{}{sign}{}.{}}'.format(2.7182818284, '>', 10, 3, sign='+'))
#      +2.72


# custom object: define __format__() in class object
class HAL9000(object):

    def __format__(self, format):
        if (format == 'open-the-pod-bay-doors'):
            return "I'm afraid I can't do that."
        return 'HAL 9000'
print('{:open-the-pod-bay-doors}'.format(HAL9000()))
# I'm afraid I can't do that.

```



## 2. Regular Expression

A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. Regular expressions are widely used in UNIX world.

```python
import re
```



### 2.1 RegEx Functions

| Function     | Description                                                  |
| :----------- | :----------------------------------------------------------- |
| findall      | Returns a list containing **all matches**                    |
| search       | Returns a *Match object* if there is a match anywhere in the string |
| split        | Returns a list where the string has been split at each match, with extra `maxsplit` parameter |
| sub          | Replaces one or many matches with a string, with the extra `count` parameter |
|              |                                                              |
| Match Object | an object containing information about the search and the result. |
| .span()      | returns a tuple containing the start-, and end positions of the match |
| .string      | returns the string passed into the function                  |
| .group()     | returns the part of the string where there was a match       |



### Example:

```python
import re

# Q1: 
re.findall("aix*", "The rain in Spain falls mainly in the plain!")

# Q2: 
re.findall("al{2}", "The rain in Spain falls mainly in the plain!")

# Q3:
re.findall("falls|stays", "The rain in Spain falls mainly in the plain!")

# Q4:
re.search("\s", "The rain in Spain").start()

# Q5:
re.split("\s", "The rain in Spain")

# Q6:
re.sub("\s", "  ", "The rain in Spain", 2)

# Q7:
re.search(r"\bS\w+", "The rain in Spain").span()
re.search(r"\bS\w+", "The rain in Spain").group()



# Result:
# R1: Check if the string contains "ai" followed by 0 or more "x" characters: 
['ai', 'ai', 'ai', 'ai']
# R2: Check if the string contains "a" followed by exactly two "l" characters:
['all']
# R3: Check if the string contains either "falls" or "stays":
['falls']
# R4: Search for the first white-space character in the string:
3
# R5: Split at each white-space character:
['The', 'rain', 'in', 'Spain']
# R6: Replace the first 2 occurrences:
'The  rain  in Spain'
# R7: Looks for any words that starts with an upper case "S"
# Print the position (start- and end-position) of the first match occurrence.
(12, 17)
# Print the part of the string where there was a match.
'Spain'

```



## 3. Threading

Python threading allows you to have different parts of your program run concurrently and can simplify your design.













## 4. OOP in Python 

### 4.1 Class

```python
class Parrot:

    # class attribute
    species = "bird"

    # instance attribute
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # instance method
    def sing(self, song):
        return "{} sings {}".format(self.name, song)
    def dance(self):
        return "{} is now dancing".format(self.name)


# instantiate the Parrot class
blu = Parrot("Blu", 10)

# access the class attributes
print("Blu is a {}".format(blu.__class__.species))
print("Blu is a {}".format(blu.species))  # another way

# access the instance attributes
print("{} is {} years old".format( blu.name, blu.age))

# call our instance methods
print(blu.sing("'Happy'"))
print(blu.dance())

# create another attribute
blu.new = 1

```



### 4.2 Inheritance

Generally when overriding a base method, we tend to extend the definition rather than simply replace it. We can use `super().__init__()`.

Two built-in functions `isinstance()` and `issubclass()` are used to check inheritances. 



#### Multiple Inheritance

```python
class Base1:
    pass
class Base2:
    pass
class MultiDerived(Base1, Base2):
    pass
```

In the multiple inheritance scenario, any specified attribute is searched first in the current class. If not found, the search continues into parent classes in depth-first, **left-right** fashion without searching same class twice.

So, in the above example of `MultiDerived` class the search order is [`MultiDerived`, `Base1`, `Base2`, `object`]. 



#### Multilevel Inheritance

```python
class Base:
    pass
class Derived1(Base):
    pass
class Derived2(Derived1):
    pass
```







### 4.3 Encapsulation

Using OOP in Python, we can restrict access to methods and variables. This prevent data from direct modification which is called encapsulation. In Python, we denote private/protected attribute using underscore as prefix i.e single `_` or double `__`.



```python
class Computer:

    def __init__(self):
        self.__maxprice = 900

    def sell(self):
        print("Selling Price: {}".format(self.__maxprice))

    def setMaxPrice(self, price):
        self.__maxprice = price

c = Computer()
c.sell()


# change the price [note: this will not change]
c.__maxprice = 1000
c.sell()

# using setter function
c.setMaxPrice(1000)
c.sell()
```



```
Selling Price: 900
Selling Price: 900
Selling Price: 1000
```



In fact, protected `_` doesn't prevent instance variables from accessing or modifyingthe instance. 

Python performs name mangling of private variables. Every member with  double underscore will be changed to `_object._class__`variable. If so  required, it can still be accessed from outside the class, but the  practice should be refrained.    

```shell
>>> c = Computer()
>>> c.__maxprice
AttributeError: 'Computer' object has no attribute '__maxprice'

>>> c = Computer()
>>> c._Computer__maxprice
900
>>> c._Computer__maxprice = 1000
>>> c._Computer__maxprice
1000
```





### 4.4 Polymorphism

Polymorphism is an ability (in OOP) to use common interface for multiple form (data types).

Suppose, we need to color a shape, there are multiple shape option (rectangle, square, circle). However we could use same method to color any shape. This concept is called Polymorphism.

```python
class Parrot:

    def fly(self):
        print("Parrot can fly")
    
    def swim(self):
        print("Parrot can't swim")

class Penguin:

    def fly(self):
        print("Penguin can't fly")
    
    def swim(self):
        print("Penguin can swim")

# common interface
def flying_test(bird):
    bird.fly()

#instantiate objects
blu = Parrot()
peggy = Penguin()

# passing the object
flying_test(blu)
flying_test(peggy)
```

```
Parrot can fly
Penguin can't fly
```



### 4.5 Operator Overloading

Binary Operators:

| OPERATOR |        MAGIC METHOD         |
| :------: | :-------------------------: |
|  **+**   |   `__add__(self, other)`    |
|  **–**   |   `__sub__(self, other)`    |
|  *****   |   `__mul__(self, other)`    |
|  **/**   | `__truediv__(self, other)`  |
|  **//**  | `__floordiv__(self, other)` |
|  **%**   |   `__mod__(self, other)`    |
| ***\***  |   `__pow__(self, other)`    |

Comparison Operators :

| OPERATOR |     MAGIC METHOD      |
| :------: | :-------------------: |
|  **<**   | `__lt__(self, other)` |
|  **>**   | `__gt__(self, other)` |
|  **<=**  | `__le__(self, other)` |
|  **>=**  | `__ge__(self, other)` |
|  **==**  | `__eq__(self, other)` |
|  **!=**  | `__ne__(self, other)` |

Assignment Operators :

| OPERATOR |         MAGIC METHOD         |
| :------: | :--------------------------: |
|  **-=**  |   `__isub__(self, other)`    |
|  **+=**  |   `__iadd__(self, other)`    |
|  ***=**  |   `__imul__(self, other)`    |
|  **/=**  |   `__idiv__(self, other)`    |
| **//=**  | `__ifloordiv__(self, other)` |
|  **%=**  |   `__imod__(self, other)`    |
| ***\*=** |   `__ipow__(self, other)`    |

Unary Operators :

| OPERATOR |       MAGIC METHOD        |
| :------: | :-----------------------: |
|  **–**   |  `__neg__(self, other)`   |
|  **+**   |  `__pos__(self, other)`   |
|  **~**   | `__invert__(self, other)` |



## 5. Python Iterators & Generators

Python **iterator object** must implement two special methods, `__iter__()` and `__next__()`, collectively called the **iterator protocol**.

An object is called **iterable** if we can get an iterator from it.

The `iter()` function (which in turn calls the `__iter__()` method) returns an iterator from them.

The `next()` function is same as `__next__` method



Example:

```python
class PowTwo:
    """Class to implement an iterator
    of powers of two"""

    def __init__(self, max = 0):
        self.max = max

    def __iter__(self):
        self.n = 0
        return self

    def __next__(self):
        if self.n <= self.max:
            result = 2 ** self.n
            self.n += 1
            return result
        else:
            raise StopIteration
```

We can use a for loop:

```python
for i in PowTwo(5):
    print(i)
```



### How for loop actually works?

```python
for element in iterable:
    # do something with element
    
# create an iterator object from that iterable
iter_obj = iter(iterable)
# infinite loop
while True:
    try:
        # get the next item
        element = next(iter_obj)
        # do something with element
    except StopIteration:
        # if StopIteration is raised, break from loop
        break    
```



### Generators

There is a lot of overhead in building an iterator in Python; we have to implement a class with `__iter__()` and `__next__()` method, keep track of internal states, raise `StopIteration` when there was no values to be returned etc.

It is fairly simple to create a generator in Python. It is as easy as defining a normal function with `yield` statement instead of a `return` statement.

If a function contains at least one `yield` statement (it may contain other `yield` or `return` statements), it becomes a generator function. Both `yield` and `return` will return some value from a function.

The **difference** is that, while a `return` statement terminates a function entirely, `yield` statement pauses the function saving all its states and later continues from there on successive calls.



Simple Example:

```python
# A simple generator function
def my_gen():
    n = 1
    print('This is printed first')
    # Generator function contains yield statements
    yield n

    n += 1
    print('This is printed second')
    yield n

    n += 1
    print('This is printed at last')
    yield n

# use
a = my_gen()
next(a)
# print: This is printed first
# print: 1

# Using for loop
for item in my_gen():
    print(item)    
```



### Python Generator Expression

The syntax for generator expression is similar to that of a **list comprehension** in Python. But the square brackets are replaced with round parentheses.

The major difference between a list comprehension and a generator expression is that while list comprehension produces the entire list, generator expression produces one item at a time.

They are kind of lazy, producing items only when asked for. For this reason, a generator expression is much more **memory efficient** than an equivalent list comprehension.

```python
# Initialize the list
my_list = [1, 3, 6, 10]

# square each term using list comprehension
[x**2 for x in my_list]
# Output: [1, 9, 36, 100]

# same thing can be done using generator expression
(x**2 for x in my_list)
# Output: <generator object <genexpr> at 0x0000000002EBDAF8>
```



Generator expression can be used inside functions. When used in such a way, the round parentheses can be dropped.

```python
>>> sum(x**2 for x in my_list)
146
>>> max(x**2 for x in my_list)
100
```





## 6. Python Decorators

### Python Closures

A function defined inside another function is called a **nested function**. Nested functions can access variables of the enclosing scope.

```python
def print_msg(msg):
# This is the outer enclosing function

    def printer():
# This is the nested function
        print(msg)

    return printer  # this got changed

# Now let's try calling this function.
# Output: Hello
another = print_msg("Hello")
another()
```

This technique by which some data (`"Hello"`) gets attached to the code is called **closure **in Python.

This value in the enclosing scope is remembered even when the variable goes out of scope or the function itself is removed from the current namespace.



The criteria that must be met to create closure in Python are summarized in the following points.

- We must have a nested function (function inside a function).
- The nested function must refer to a value defined in the enclosing function.
- The enclosing function must return the nested function.



If it is a closure function, the function object will have a `__closure__` attribute that returns a tuple of cell objects.

```python
another.__closure__[0].cell_contents
```



### Python Decorators

Python has an interesting feature called **decorators** to add functionality to an existing code.

This is also called **metaprogramming** as a part of the program tries to modify another part of the program at compile time.



Such function that take other functions as arguments are also called **higher order functions**. 

Furthermore, a function can return another function.



Functions and methods are called **callable** as they can be called.

In fact, any object which implements the special method `__call__()` is termed callable. So, in the most basic sense, a decorator is a callable that returns a callable.

Basically, **a decorator takes in a function, adds some functionality and returns it.**

```python
def make_pretty(func):
    def inner():
        print("I got decorated")
        func()
    return inner

def ordinary():
    print("I am ordinary")
```



Generally, we decorate a function and reassign it as,

```python
ordinary = make_pretty(ordinary)
```

This is a common construct and for this reason, Python has a syntax to simplify this.

We can use the `@` symbol along with the name of the decorator function and place it above the definition of the function to be decorated. For example,

```python
@make_pretty
def ordinary():
    print("I am ordinary")

# is equivalent to
def ordinary():
    print("I am ordinary")
ordinary = make_pretty(ordinary)
```

### Chaining Decorators in Python

```python
def star(func):
    def inner(*args, **kwargs):
        print("*" * 30)
        func(*args, **kwargs)
        print("*" * 30)
    return inner

def percent(func):
    def inner(*args, **kwargs):
        print("%" * 30)
        func(*args, **kwargs)
        print("%" * 30)
    return inner

@star
@percent
def printer(msg):
    print(msg)
    
printer("Hello")
```

this is equivalent to 

```python
printer = star(percent(printer))
```

The output:

```
******************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Hello
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
******************************
```



## 7. Python @Property



Old Example:

```python
class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32
```

Whenever we assign or retrieve any object attribute like `temperature`, as show above, Python searches it in the object's `__dict__` dictionary.

```python
m = Celsius(37)
m.__dict__
# print: {'temperature': 37}
```

```python
# Making Getters and Setter methods
class Celsius:
    def __init__(self, temperature=0):
        self.set_temperature(temperature)

    def to_fahrenheit(self):
        return (self.get_temperature() * 1.8) + 32

    # getter method
    def get_temperature(self):
        return self._temperature

    # setter method
    def set_temperature(self, value):
        if value < -273.15:
            raise ValueError("Temperature below -273.15 is not possible.")
        self._temperature = value
```

However, the bigger problem with the above update is that all the  programs that implemented our previous class have to modify their code  from `obj.temperature` to `obj.get_temperature()` and all expressions like `obj.temperature = val` to `obj.set_temperature(val)`.

This refactoring can cause problems while dealing with hundreds of thousands of lines of codes.



```python
# using property class
class Celsius:
    def __init__(self, temperature = 0):
        self._temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    def get_temperature(self):
        print("Getting value")
        return self._temperature

    def set_temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value

    temperature = property(get_temperature,set_temperature)
```

The last line of the code, makes a property object `temperature`. Simply put, property attaches some code (`get_temperature` and `set_temperature`) to the member attribute accesses (`temperature`).

Any code that retrieves the value of `temperature` will automatically call `get_temperature()` instead of a dictionary (`__dict__`) look-up. Similarly, any code that assigns a value to `temperature` will automatically call `set_temperature()`. This is one cool feature in Python.

Finally note that, the actual temperature value is stored in the private variable `_temperature`. The attribute `temperature` is a property object which provides interface to this private variable.



In Python, `property()` is a built-in function that creates and returns a property object. The signature of this function is

```python
property(fget=None, fset=None, fdel=None, doc=None)
```

where, `fget` is function to get value of the attribute, `fset` is function to set value of the attribute, `fdel` is function to delete the attribute and `doc` is a string (like a comment). As seen from the implementation, these function arguments are optional. So, a property object can simply be created as follows.

So, 

```python
temperature = property(get_temperature,set_temperature)

# also equivalent to
temperature = property(get_temperature)
temperature = temperature.setter(set_temperature)
```

We can use decorator :

```python
class Celsius:
    def __init__(self, temperature = 0):
        self._temperature = temperature

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    @property
    def temperature(self):
        print("Getting value")
        return self._temperature

    @temperature.setter
    def temperature(self, value):
        if value < -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value
        
human = Celsius(37)
print(human.temperature)
print(human.to_fahrenheit())
```

Note: For Line 3, we do not use `self.set_temperature(temperature)`. If so, se have now two ways to access or change the value of x: Either by using `p1.temperature = 42` or by `p1.set_temperature(42)`. This way we are violating one of the  fundamentals of Python: "There should be one-- and preferably only one  --obvious way to do it.”

it seems it is same: `self.temperature = temperature` OR `self._temperature = temperature`



## 8. Python Multiple Constructor

https://www.pythonpool.com/python-multiple-constructors/

- Constructor overloading based on arguments
- Methods calling from `__init__`
- `@classmethod` decorator

**Python Constructor overloading based on arguments as Multiple Constructors:**

```python
class eaxmple: 
   
    # constructor overloading based on args 
    def __init__(self, *args): 
   
        # if args are more than 1 
        # sum of args 
        if len(args) > 1: 
            self.answer = 0
            for i in args: 
                self.answer += i 
   
        # if arg is an integer 
        # square the arg 
        elif isinstance(args[0], integer): 
            self.answer = args[0]*args[0] 
   
        # if arg is string 
        # Print with hello
        elif isinstance(args[0], str): 
            self.answer = "Hello! "+args[0]+"."
   
   
e1 = example(1, 2, 3, 6, 8) 
print("Sum of list :", e1.answer) 
   
e2 = example(6) 
print("Square of integer :", e2.answer) 
   
e3 = example("Programmers") 
print("String :", e3.answer) 
```

```
Sum of list : 20
Square of integer : 36
String : Hello! Programmers
```

**Python Methods calling from init as Multiple Constructors:**

```python
class equations: 
   
  # single constructor to call other methods 
    def __init__(self, *abc): 
   
        # when 2 arguments are passed 
        if len(abc) == 2: 
            self.ans = self.eq1(abc) 
   
        # when 3 arguments are passed 
        elif len(abc) == 3: 
            self.ans = self.eq2(abc) 
   
        # when more than 3 arguments are passed 
        else: 
            self.ans = self.eq3(abc) 
   
    def eq1(self, args): 
        x = (args[0]*args[0])+(args[1]*args[1]) 
        return x 
 
    def eq2(self, args): 
        y = args[0]+args[1]-args[2] 
        return y
   
    def eq3(self, args): 
        temp = 0
        for i in range(0, len(args)): 
            temp += args[i]*args[i] 
           
        temp = temp/5.0
        z = temp 
        return z 
   
   
abc1 = equations(4, 2) 
abc2 = equations(4, 2, 3) 
abc3 = equations(1, 2, 3, 4, 5) 
   
print("equation 1 :", abc1.ans) 
print("equation 2 :", abc2.ans) 
print("equation 3 :", abc3.ans) 
```

```
equation 1 : 12
equation 2 : 17
equation 3 : 11.0
```

**Python Methods calling from init as Multiple Constructors:**

```python
class equations: 
   
    # basic constructor 
    def __init__(self, x): 
        self.ans = x 
 
    @classmethod
    def eq1(obj, args): 
         
      # create an object for the class to return 
        a = obj((args[0]*args[0])+(args[1]*args[1]))
        return a 
  
    @classmethod
    def eq2(obj, args): 
        b = obj(args[0]+ args[1] - args[2]) 
        return b 
   
    @classmethod
    def eq3(obj, args): 
        temp = 0
   
        # square of each element 
        for i in range(0, len(args)): 
            temp += args[i]*args[i] 
   
        temp = temp/5.0
        z = obj(temp) 
        return z 
   
   
li = [[4, 2], [4, 2, 3], [1, 2, 3, 4, 5]] 
i = 0
   
# loop to get input three times 
while i < 3: 
   
    input = li[i] 
   
    # no.of.arguments = 2 
    if len(input) == 2: 
        p = equations.eq1(input) 
        print("equation 1 :", p.ans) 
   
    # no.of.arguments = 3 
    elif len(input) == 3: 
        p = equations.eq2(input) 
        print("equation 2 :", p.ans) 
   
    # More than three arguments 
    else: 
        p = equations.eq3(input) 
        print("equation 3 :", p.ans) 
   
    #increment loop         
    i += 1
```

```
equation 1 : 12
equation 2 : 17
equation 3 : 11.0
```



## 9. Python @classmethod & @staticmethod







## 10. Bitwise Operator

- character conversion: `chr(), ord()`

- e.g. 8 bits (-128 to 127)

    - Positive number: 
        - first bit = 0
        - `00000000` to `01111111` is 0 to 127
    - Negative number: 
        - first bit = 1,  
        - -x is the complement of (x-1)
        - `-5` -> `~4` -> `~0000100` -> `11111011` -> $-2^8+2^7+2^6+\ldots=-5$ 

- e.g.

    - `a=60 or 0011 1100`,
    - `b=13 or 0000 1101`

    

| Operator  | Description        | Example            | Comment       |
| --------- | ------------------ | ------------------ | ------------- |
| `a & b`   | Binary AND         | `0000 1100 or 12`  |               |
| `a | b`   | Binary OR          | `0011 1101 or 61`  |               |
| `a ^ b`   | Binary XOR         | `0011 0001 or 49`  | `a ^ a = 0`   |
| `~ a`     | Binary Complement  | `1100 0011 or -61` |               |
| `a <<= 1` | Binary Left Shift  | `0111 1000 or 120` | $a*2^n$       |
| `a >>= 1` | Binary Right Shift | `0001 1110 or 30`  | $a \ / \ 2^n$ |
|           |                    |                    |               |

 

```python
print(~~~~~~5)

# Result:
5
```

`~x` is equivalent to `-(x+1)`.





